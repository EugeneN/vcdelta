// Generated by CoffeeScript 1.8.0
(function() {
  var BUILD_ID_FN, BUNDLE_FILTER, DELTA_FN, E_BAD_ARGS, E_ERROR, E_OK, E_VERSION, VERSION, apply_delta, calc_delta, from_json, fs, gen_delta, get_build_id, main, minimist, mkdirp, parse_args, path, read, say, toDict, to_bundle, to_json, to_path, vcd, vcdiff, write,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  mkdirp = require("mkdirp");

  minimist = require('minimist');

  vcdiff = require('../lib/vcdiff');

  DELTA_FN = "delta.json";

  BUILD_ID_FN = "build_id.json";

  BUNDLE_FILTER = function(bundle_name) {
    return bundle_name.indexOf("-min.js") > 0;
  };

  VERSION = (require('../package')).version;

  E_OK = 0;

  E_BAD_ARGS = 1;

  E_ERROR = 2;

  E_VERSION = 3;

  to_path = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return path.resolve.apply(path, [process.cwd()].concat(args));
  };

  vcd = new vcdiff.Vcdiff;

  vcd.blockSize = 20;

  calc_delta = function(base, target) {
    return vcd.encode(base, target);
  };

  apply_delta = function(base, delta) {
    return vcd.decode(base, delta);
  };

  read = function(fn) {
    return fs.readFileSync(fn).toString();
  };

  write = function(fn, content) {
    mkdirp.sync(path.dirname(fn));
    return fs.writeFileSync(fn, content);
  };

  to_json = function(data) {
    return JSON.stringify(data);
  };

  from_json = function(data) {
    return JSON.parse(data);
  };

  to_bundle = function(fn) {
    return fn.replace('-min.js', '');
  };

  say = function() {
    var m;
    m = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.error.apply(console, m);
  };

  gen_delta = function(base, target) {
    return [to_bundle(path.basename(target)), calc_delta(read(base), read(target))];
  };

  get_build_id = function(build_root) {
    var bi;
    bi = JSON.parse(read(to_path(build_root, BUILD_ID_FN)));
    return bi.buildid;
  };

  toDict = function(list_of_lists) {
    var x;
    x = {};
    list_of_lists.map(function(_arg) {
      var k, v;
      k = _arg[0], v = _arg[1];
      return x[k] = v;
    });
    return x;
  };

  parse_args = function(argv) {
    return minimist(argv.slice(2));
  };

  main = function(argv) {
    var delta_root, deltas, e, new_build_id, new_build_root, old_build_id, old_build_root, realms, v, version, _ref;
    _ref = parse_args(argv), old_build_root = _ref.old_build_root, new_build_root = _ref.new_build_root, delta_root = _ref.delta_root, v = _ref.v, version = _ref.version;
    if (v === true) {
      say("Version " + VERSION);
      process.exit(E_VERSION);
    }
    if (!(old_build_root && new_build_root && delta_root)) {
      say("Usage:\n\t@me --old_build_root=<...> --new_build_root=<...> --delta_root=<...>\nor, to get version:\n\t@me -v");
      process.exit(E_BAD_ARGS);
    }
    try {
      old_build_id = get_build_id(old_build_root);
      new_build_id = get_build_id(new_build_root);
      realms = fs.readdirSync(new_build_root).filter(function(fn) {
        return !fs.statSync(to_path(new_build_root, fn)).isFile();
      }).map(function(fn) {
        return path.basename(fn);
      });
      deltas = realms.map(function(realm) {
        var files;
        files = fs.readdirSync(to_path(new_build_root, realm)).filter(BUNDLE_FILTER).map(function(fn) {
          return path.basename(fn);
        });
        return [
          realm, toDict(files.map(function(fn) {
            return gen_delta(to_path(old_build_root, realm, fn), to_path(new_build_root, realm, fn));
          }))
        ];
      });
      return deltas.map(function(_arg) {
        var delta, realm;
        realm = _arg[0], delta = _arg[1];
        return write(to_path(delta_root, old_build_id, new_build_id, realm, DELTA_FN), to_json(delta));
      });
    } catch (_error) {
      e = _error;
      say("Sorry, an error occured:\n\t" + e);
      return process.exit(E_ERROR);
    }
  };

  module.exports = main;

}).call(this);
